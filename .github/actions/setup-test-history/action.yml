name: 'Setup Test History and Baseline'
description: 'Downloads test history from S3 and configures baseline for comparisons - v2'

inputs:
  aws-access-key-id:
    description: 'AWS Access Key ID'
    required: true
  aws-secret-access-key:
    description: 'AWS Secret Access Key'
    required: true
  aws-region:
    description: 'AWS Region'
    required: true

outputs:
  baseline-run-id:
    description: 'Baseline run ID for comparison'
    value: ${{ steps.setup-baseline.outputs.baseline-run-id }}

runs:
  using: 'composite'
  steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ inputs.aws-access-key-id }}
        aws-secret-access-key: ${{ inputs.aws-secret-access-key }}
        aws-region: ${{ inputs.aws-region }}

    - name: Download test history from S3
      shell: bash
      run: |
        mkdir -p history

        # Clean branch name for folder structure
        CLEAN_BRANCH=$(echo "${{ github.ref_name }}" | sed 's/[^a-zA-Z0-9._-]/_/g')
        mkdir -p "history/${CLEAN_BRANCH}"

        # Download main history file
        aws s3 cp s3://kaleidos-qa-reports/test-history.json test-history.json 2>/dev/null || echo "No main history file found"

        # Debug downloaded file
        if [ -f "test-history.json" ]; then
          echo "üì• Downloaded main history file: $(wc -c < test-history.json) bytes"
          echo "üîç Downloaded file structure: $(node -pe 'try { const h=JSON.parse(require("fs").readFileSync("test-history.json", "utf8")); Object.keys(h).join(",") } catch(e) { "error" }')"
          echo "üîç Downloaded file runs: $(node -pe 'try { JSON.parse(require("fs").readFileSync("test-history.json", "utf8")).runs?.length || 0 } catch(e) { 0 }')"
        fi

        # Download branch-specific history files
        aws s3 sync s3://kaleidos-qa-reports/history/${CLEAN_BRANCH}/ history/${CLEAN_BRANCH}/ 2>/dev/null || echo "No branch-specific history found"

        # Debug branch files
        if [ -d "history/${CLEAN_BRANCH}" ]; then
          echo "üìÅ Branch history files found:"
          ls -la "history/${CLEAN_BRANCH}/" || echo "No files in branch directory"
          
          for file in history/${CLEAN_BRANCH}/history_*.json; do
            if [ -f "$file" ]; then
              echo "üìÑ Branch file: $file ($(wc -c < "$file") bytes)"
              echo "üîç Branch file runs: $(node -pe 'try { JSON.parse(require("fs").readFileSync("'$file'", "utf8")).runs?.length || 0 } catch(e) { 0 }')"
            fi
          done
        fi

    - name: Merge test histories
      shell: bash
      run: |
        CLEAN_BRANCH=$(echo "${{ github.ref_name }}" | sed 's/[^a-zA-Z0-9._-]/_/g')

        # FORCE CLEANUP: Delete all malformed history files with 0 runs
        echo "üßπ Cleaning up malformed history files with 0 runs..."

        if [ -f "test-history.json" ]; then
          RUNS_COUNT=$(node -pe 'try { JSON.parse(require("fs").readFileSync("test-history.json", "utf8")).runs?.length || 0 } catch(e) { 0 }')
          if [ "$RUNS_COUNT" -eq 0 ]; then
            echo "üóëÔ∏è Deleting malformed main history file (0 runs): test-history.json"
            rm -f test-history.json
          fi
        fi

        if [ -d "history/${CLEAN_BRANCH}" ]; then
          for file in history/${CLEAN_BRANCH}/*.json; do
            if [ -f "$file" ]; then
              RUNS_COUNT=$(node -pe 'try { JSON.parse(require("fs").readFileSync("'$file'", "utf8")).runs?.length || 0 } catch(e) { 0 }')
              if [ "$RUNS_COUNT" -eq 0 ]; then
                echo "üóëÔ∏è Deleting malformed branch history file (0 runs): $file"
                rm -f "$file"
              fi
            fi
          done
        fi

        # Create array of history files to merge (only valid ones remaining)
        HISTORY_FILES=()

        # Add main history file if it exists AND has runs > 0
        if [ -f "test-history.json" ]; then
          RUNS_COUNT=$(node -pe 'try { JSON.parse(require("fs").readFileSync("test-history.json", "utf8")).runs?.length || 0 } catch(e) { 0 }')
          if [ "$RUNS_COUNT" -gt 0 ]; then
            HISTORY_FILES+=("test-history.json")
            echo "‚úÖ Found valid main history file with $RUNS_COUNT runs: test-history.json"
          fi
        fi

        # Add branch-specific history files if they have runs > 0
        if [ -d "history/${CLEAN_BRANCH}" ]; then
          for file in history/${CLEAN_BRANCH}/history_*.json; do
            if [ -f "$file" ]; then
              RUNS_COUNT=$(node -pe 'try { JSON.parse(require("fs").readFileSync("'$file'", "utf8")).runs?.length || 0 } catch(e) { 0 }')
              if [ "$RUNS_COUNT" -gt 0 ]; then
                HISTORY_FILES+=("$file")
                echo "‚úÖ Found valid branch history file with $RUNS_COUNT runs: $file"
              fi
            fi
          done
        fi

        # If we have multiple valid history files, merge them
        if [ ${#HISTORY_FILES[@]} -gt 1 ]; then
          echo "Merging ${#HISTORY_FILES[@]} valid history files..."
          
          # Debug: show content of each file before merge
          for file in "${HISTORY_FILES[@]}"; do
            if [ -f "$file" ]; then
              echo "üìÑ File: $file ($(wc -c < "$file") bytes)"
              echo "üîç Runs in $file: $(node -pe 'try { JSON.parse(require("fs").readFileSync("'$file'", "utf8")).runs?.length || 0 } catch(e) { 0 }')"
              echo "üîç Tests in $file: $(node -pe 'try { Object.keys(JSON.parse(require("fs").readFileSync("'$file'", "utf8")).tests || {}).length } catch(e) { 0 }')"
            fi
          done
          
          npx playwright-smart-reporter-merge-history "${HISTORY_FILES[@]}" -o merged-history.json --max-runs 15
          
          if [ -f "merged-history.json" ]; then
            mv merged-history.json test-history.json
            echo "‚úÖ Successfully merged history files"
            echo "üìä Merged history runs count: $(node -pe 'try { JSON.parse(require("fs").readFileSync("test-history.json", "utf8")).runs?.length || 0 } catch(e) { 0 }')"
          else
            echo "‚ùå Failed to merge history files"
          fi
        elif [ ${#HISTORY_FILES[@]} -eq 1 ]; then
          echo "Using single valid history file: ${HISTORY_FILES[0]}"
          echo "üîç Single file runs count: $(node -pe 'try { JSON.parse(require("fs").readFileSync("'${HISTORY_FILES[0]}'", "utf8")).runs?.length || 0 } catch(e) { 0 }')"
          # Copy to root location if not already there
          if [ "${HISTORY_FILES[0]}" != "test-history.json" ]; then
            cp "${HISTORY_FILES[0]}" test-history.json
          fi
        else
          echo "üîÑ No valid history files with runs found. Searching for alternative history files in S3..."
          
          # Try to download any additional history files from S3 with different patterns
          echo "üîç Searching for test-results files in S3..."
          aws s3 ls s3://kaleidos-qa-reports/ --recursive | grep -E "(test-results|history)" || echo "No additional files found"
          
          # Try to download test-results files that might contain usable data
          for pattern in "test-results-*.json" "history-*.json" "playwright-report-*.json"; do
            echo "Searching for pattern: $pattern"
            aws s3 cp s3://kaleidos-qa-reports/ . --recursive --exclude "*" --include "$pattern" 2>/dev/null || echo "No files found for pattern $pattern"
          done
          
          # List downloaded files
          echo "üìÅ Downloaded files:"
          ls -la *.json 2>/dev/null || echo "No JSON files found"
          
          # Look for any JSON file with test results that we can use
          FOUND_RESULTS=false
          for file in test-results-*.json history-*.json playwright-report-*.json; do
            if [ -f "$file" ]; then
              echo "üîç Checking file: $file"
              # Check if file contains test results we can convert
              HAS_TESTS=$(node -pe 'try { const data=JSON.parse(require("fs").readFileSync("'$file'", "utf8")); (data.tests && Array.isArray(data.tests)) || (data.suites && Array.isArray(data.suites)) } catch(e) { false }')
              if [ "$HAS_TESTS" = "true" ]; then
                echo "‚úÖ Found usable test results in: $file"
                # Convert to basic history format
                node -e "
                  const fs = require('fs');
                  try {
                    const data = JSON.parse(fs.readFileSync('$file', 'utf8'));
                    const runId = 'baseline_' + Date.now();
                    const history = {
                      runs: [{
                        id: runId,
                        startedAt: new Date().toISOString(),
                        finishedAt: new Date().toISOString(),
                        status: 'passed',
                        summary: data.stats || { passed: 0, failed: 0, total: 0 }
                      }],
                      tests: {},
                      summaries: [{
                        runId: runId,
                        passed: data.stats?.passed || 0,
                        failed: data.stats?.failed || 0,
                        total: data.stats?.total || 0
                      }]
                    };
                    fs.writeFileSync('test-history.json', JSON.stringify(history, null, 2));
                    console.log('‚úÖ Converted test results to history format');
                  } catch(e) {
                    console.log('‚ùå Failed to convert: ' + e.message);
                  }
                "
                FOUND_RESULTS=true
                break
              fi
            fi
          done
          
          if [ "$FOUND_RESULTS" = "false" ]; then
            echo "‚ùå ERROR: No usable test result files found in S3"
            echo "‚ùå Cannot create test history without valid historical data"
            echo "‚ùå Please ensure test-results files are available in s3://kaleidos-qa-reports/"
            exit 1
          fi
        fi

    - name: Setup baseline run ID
      id: setup-baseline
      shell: bash
      run: |
        # Generate unique baseline run ID based on timestamp and commit
        BASELINE_ID="${{ github.sha }}_$(date +%s)"
        echo "baseline-run-id=${BASELINE_ID}" >> $GITHUB_OUTPUT
        echo "üìù Baseline Run ID set to: ${BASELINE_ID}"

        # Export for use in subsequent steps
        echo "BASELINE_RUN_ID=${BASELINE_ID}" >> $GITHUB_ENV
